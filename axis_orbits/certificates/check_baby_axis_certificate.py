import os
import sys
import re
import time
from collections import Counter, OrderedDict, defaultdict
import numpy as np

# Standard classes implementing the Monster, G_x0, the Leech lattice
# mod 2, and the Griess algebra.
# Elements of the Monster are used for transforming vectors
# in the Griess algebra only.
# Elements of G_x0 are used for transforming vectors in the 
# Griess algebra or vectors in the Leech lattice mod 2.
from mmgroup import MM0, MMV, Xsp2_Co1, XLeech2, Cocode

#G_x0 = Xsp2_Co1  # implements an element of G_x0
#M = MM0          # implements an element of the Monster M
Griess = MMV(3)  # implements an element of the Griess Algebra mod 3


# The standard feasible axis v^- in the Griess algebra
STD_AXIS = Griess("A_2_2 - A_3_2 + A_3_3 + 2*B_3_2")


# The axis axis v^+ in fixed by the Baby Monster
FIXED_AXIS = Griess("A_2_2 - A_3_2 + A_3_3 - 2*B_3_2")
# The involution \beta^+ in Q_x0 corresponding to  v^+
FIXED_INVOLUTION = XLeech2(0, Cocode([2,3]))

def G_x0(g_str):
    """Map a string in the certificate to an element of G_x0

    Raises an exception if the element is not in the Baby Monster
    """ 
    g = Xsp2_Co1(g_str)
    assert FIXED_INVOLUTION * g == FIXED_INVOLUTION
    return g


def M(*m_data):
    """Map input to an element of the Baby Monster

    Input is as for the construtor of class MM

    Raises an exception if the element is not in the Baby Monster
    """ 
    g = MM0(*m_data)
    assert FIXED_AXIS * g == FIXED_AXIS
    return g



# The triality element in the Monster and its inverse
T1 = M('t', 1); T2 = M('t', 2) 

# Number of feasible type-4 vectors in the Leech lattice mod 2
NUM_FEASIBLE_TYPE4_VECTORS = 46575


if __name__ == "__main__":
     sys.path.append(os.path.realpath(".."))

# Parse a line of the certificate
from certificates.check_axis_certificate import parse_line


def find_axes(certificate_path):
    """Pass through a certificate for finding  descriptions of axes

    The function parses the lines of the file named
    ``certificate_path`` and returns a dictionary containing the
    axes found. This directory maps the axis names (given as strings)
    to the representatives of the G_x0 orbtis of the axes (given
    as elements of the Griess algebra). 
    """
    axis_dict = OrderedDict()
    for s in open(certificate_path):
        tag, n, g = parse_line(s)
        if tag == "axis":
            axis_dict[n] = STD_AXIS * MM0(g) 
    return axis_dict


# A collection of data for checking a G_x0 orbit of an axis.
# For members, see file check_axis_certificate.py
from certificates.check_axis_certificate import AxisChecker

# Return image of Omega under the action of g, for g in G_x0
from certificates.check_axis_certificate import img_Omega_G_x0

# Union-find algorithm for vectors in Leech lattice mod 2.
# For detals, see file check_axis_certificate.py
from certificates.check_axis_certificate import UnionFindLeech2

def check_axis(ch):
    """Check data for an axis read from a certificate

    Here parameter ``ch`` must be an instance of class ``AxisChecker``.
    That instance contains data about a specific axis ``ax``
    collected from the certificate.

    Let G be the subgroup of G_x0 generated by the list in member
    ``ch.centralizer``. We compute the orbits of G on the type-4
    vectors in the Leech lattice mod 2 using class ``UnionFindLeech2``.
    In a check prior to the call of this function we have already
    verified that G is a subgroup of the centralizer of the axis. 

    Let ``orb`` be the list of representatives of N_x0 orbits
    contained in the G_x0 orbit of the axis, as given by the list
    in member ``ch.orbits``. The entry in the list for an axis
    ``ax1`` representing an N_x0 orbit contains an element ``h``
    of G_x0 with ``ax * h == ax1``, and a number ``k`` indicating
    the size of the orbit.

    As in the paper, we associate axis ``ax1 = ax * h`` with the
    element ``Omega * h**-1`` in the Leech lattice mod 2, where
    ``Omega`` is the standard frame in the Leech lattice mod 2. 
    For each axis ``ax1`` to which the list ``ch.orbits`` refers,
    we check that the G orbit of ``Omega * h**-1`` has precisely
    the size ``k`` stored for that axis.

    We also check that the sum of all values ``k`` obtained from
    the list ``ch.orbits`` is equal to the number of type-4
    vectors in the Leech lattice mod 2.

    If any of these checks fails the function raisens an execption.
    """
    assert isinstance(ch, AxisChecker)
    uf = UnionFindLeech2()
    d = {}
    for g in ch.centralizer:
        uf.union_g(g)
    for orbit_size, h in ch.orbits:
        d[img_Omega_G_x0(h**-1)] = orbit_size
    counter = uf.counter()
    #print(counter)
    for v, orbit_size in d.items():
        assert counter[uf.find(v)] == orbit_size
    #print(sum(d.values()))
    assert sum(d.values()) == NUM_FEASIBLE_TYPE4_VECTORS


def get_suborbits_from_shelve():
    """Return the suborbit table from the shelve.

    This table corresponds to Table 2 in the paper.
    The function returns None if no suborbit table in the shelve
    has been found.
    """
    import shelve
    THIS_DIR = os.path.split(__file__)[0]
    SHELVE_DIR = os.path.join(THIS_DIR, "..", "baby_axis", "shelve")
    SHELVE_NAME = os.path.realpath(
        os.path.join(SHELVE_DIR, "mat22_orbit_tables"))
    try:
        with shelve.open(SHELVE_NAME) as db:
            shelve_suborbits = db["mat22_suborbits"]
        return shelve_suborbits
    except:
        return None
     

def get_suborbit_table_from_certificate(certificate_path):
    """Return suborbit table computed from the certificate.

    This table corresponds to Table 2 in the paper.
    """
    d = defaultdict(int)
    for s in open(certificate_path):
        tag, n, g = parse_line(s)
        if tag == 'axis':
            current_axis = n
        if tag == 'orb':
            current_orbit_size = n
        if tag.startswith('tau'):
            d[current_axis, n] += current_orbit_size
    return d

def check_suborbits_against_shelve(certificate_path):
    """Check suborbit table computed from certificate against shelve.

    This suborbit table is Table 2 in the paper.
    The function raises an exception if the suborbit table computed
    from the certificate differs from the corresponding table in the
    shelve. It prints a message if no shelve containg a suitable
    suborbit table  has been found. 
    """
    d_shelve = get_suborbits_from_shelve()
    if d_shelve is not None:
        print("""
Computing Table 4 in the paper from the certificate ...""")
        d_cert = get_suborbit_table_from_certificate(certificate_path)
        assert d_cert == d_shelve, (d_cert , d_shelve)
        print("Table agrees with corresponding table in the shelve.")
    else:
        print("""
Cannot compare certificate against data in the shelve.
No shelve containg a suitable suborbit table found!""") 
        


def check_baby_certificate(certificate_path):
    """Check the certificate for correctness.

    The function read the certificate given by parameter
    ``certificate_path``. It first computes the representatives of
    the G_x0 orbits of the axes stored in the certificate. It also
    reads the generarators of the centralizers of the axes and
    checks that they indeed centralize an axis as claimed in the
    cerificate. 

    For each axis ``ax`` representing a G_x0 orbit the function
    collects the axes representing the N_x0 orbits contained in that 
    orbit from the certificate. For any of these collected axes
    ``ax1`` the certificate contains the size of the N_x0 orbit
    of ``ax1``. The triality element ``\tau`` of the Monster and its
    inverse map ``ax1`` to axes in G_x0 orbits that may differ from
    the G_x0 orbit of``ax1``. Here the certificate contains
    information how to map the axes ``ax1 * \tau^{+-1}`` to the
    representatives of their G_x0 orbits. Thus the G_x0 orbits of
    ``ax1 * \tau^{+-1}`` may easily be obtained from the information
    in the certificate. The sizes of the N_x0 orbits of the axes
    ``ax``, and the G_x0 orbits of the images of ``ax`` under
    ``\tau^{+-1}``, are sufficient to conmpute Table 2 in the paper.

    It remains to show that the N_x0 orbits contained in a G_x0
    orbit make up the complete G_x0 orbit. The paper explains how
    this claim can be established. For doing so we collect the
    information about an axis representing a G_x0 orbit in an 
    object of class ``AxisChecker``. The we apply function
    ``check_axis`` to that object in order to verify the claim.
    As explained in the paper, we cannot and need not be sure that
    the group G_0 generated by the elements in the certificate 
    centralizing axis ``ax`` is equal to the centralizer G of axis
    ``ax`` in G_x0.

    From the infomation in the certificate we can easily compute
    Table 2 in the paper. Here we check if the Table 2 computed
    in this way agrees with the Table 2 computed by the programs
    in subdirectory 'axis' of the project. 
    """
    start_time = time.time()
    axis_dict = find_axes(certificate_path)
    #print(axis_dict.keys())
    last = None
    axes_found = set()
    print(f"Verifying certificate '{certificate_path}'")
    print("Orbits checked: ", end = "")
  
    for s in open(certificate_path):
        tag, n, g = parse_line(s)
        if tag == 'axis':
             ch = AxisChecker()
             ch.name, ch.axis = n, STD_AXIS * M(g) 
        if tag == 'cent':
             c = G_x0(g) 
             if n == 1:
                 ch.centralizer.append(c)
             assert ch.axis * c == ch.axis
        if tag == 'orb':
             orbit_size, g_orbit = n, G_x0(g)
             orbit_axis = ch.axis * g_orbit
        if tag == 'tau1':
             assert last == 'orb'
             tau_axis = orbit_axis * T1 * M(g)
             assert tau_axis ==  axis_dict[n]   
        if tag == 'tau2':
             assert last == 'tau1'
             tau_axis = orbit_axis * T2 * M(g)
             assert tau_axis ==  axis_dict[n] 
             ch.orbits.append([orbit_size, g_orbit]) 
        if tag == 'end':
             check_axis(ch)
             axes_found.add(ch.name)
             print(ch.name, end = " ", flush = True)           
             del ch 
        last = tag
    #print( set(axis_dict.keys()), axes_found)
    assert set(axis_dict.keys()) == axes_found
    t = time.time() - start_time
    print("\nCertificate is correct. Verifying took %.2f seconds" % t)
    check_suborbits_against_shelve(certificate_path)

if __name__ == "__main__":
     CERTIFICATE_PATH =  "baby_axis_certificate.txt"
     check_baby_certificate(CERTIFICATE_PATH)


