import os
import re
import time
from collections import Counter, OrderedDict, defaultdict
import numpy as np

# Standard classes implementing the Monster, G_x0, the Leech lattice
# mod 2, and the Griess algebra.
# Elements of the Monster are used for transforming vectors
# in the Griess algebra only.
# Elements of G_x0 are used for transforming vectors in the 
# Griess algebra or vectors in the Leech lattice mod 2.
from mmgroup import MM0, MMV, Xsp2_Co1, XLeech2

G_x0 = Xsp2_Co1  # implements an element of G_x0
M = MM0          # implements an element of the Monster M
Griess = MMV(3)  # implements an element of the Griess Algebra mod 3

# The standard axis v^+ in the Griess algebra
STD_AXIS = Griess("A_2_2 - A_3_2 + A_3_3 - 2*B_3_2")

# The triality element in the Monster and its inverse
T1 = M('t', 1); T2 = M('t', 2) 

# Number of type-4 vectors in the Leech lattice mod 2
NUM_TYPE4_VECTORS = 8292375



# The following stuff is required for the union-find algorithm only
from mmgroup.generators import gen_ufind_init, gen_ufind_union_affine
from mmgroup.generators import gen_ufind_find, gen_ufind_find_all_min
from mmgroup.generators import gen_ufind_make_map

# regular expression object for parsing a line of the certificate 
matchobj = re.compile(
    r"([a-z0-9]+\*?)\:(\s+([A-Z0-9]+))?(\s+(<[a-z0-9_*]+>))?")

# parse  a line of the certificate
def parse_line(s):
    """parse a line ``s`` of a certificate

    The function returns the content of the line ``s`` a triple
    ``(tag, value, g)``.

    ``tag``   is the tag at the beginning of the line, of type str

    ``value`` is the value after the tag; it may be an int or a str

    ``g``     is an element of the Monster given as a string

    The meaning of ``value`` and ``g`` depends on the ``tag``.
    All entries may be None if not present in the line ``s``.
    """ 
    m = matchobj.match(s)
    if m:
        tag, _, n, _, g = m.groups()
        if n is not None and n.isdigit():
            n = int(n)
        return tag, n, g
    else:
        return None, None, None

def find_axes(certificate_path):
    """Pass through a certificate for finding  descriptions of axes

    The function parses the lines of the file named
    ``certificate_path`` and returns a dictionary containing the
    axes found. This directory maps the axis names (given as strings)
    to the representatives of the G_x0 orbtis of the axes (given
    as elements of the Griess algebra). 
    """
    axis_dict = OrderedDict()
    for s in open(certificate_path):
        tag, n, g = parse_line(s)
        if tag == "axis":
            axis_dict[n] = STD_AXIS * MM0(g) 
    return axis_dict



class AxisChecker:
    """A collection of data for checking a G_x0 orbit of an axis

    Members are:
    
    name (str):    name of the G_x0 orbit of the axis 
    axis (Griess): the axis representing its G_x0 orbit
    centralizer (list of G_x0):
                   generates the centralizer of the axis in G_x0
    orbits (list of pairs (int, G_x0)):
                   A entry in this list corrsponds to an N_x0 orbit
                   inside the G_x0 orbit. It is pair (n, g). 
                   g is an element of G_x0 that maps member 'axis'
                   to a representative of the N_x0 orbit. 
                   n is the size of the orbit, scaled so that the
                   sum of all sizes is |G_x0 : N_x0|.
    """
    def __init__(self):
        self.orbits = []
        self.centralizer = []


def img_Omega_G_x0(g):
    """Return image of Omega under the action of g

    Here Omega is the standard co-ordinate frame in the Leech lattice
    mod 2, and g is an element of G_x0. The image is returned as an
    integer encoding a bit vector.
    """
    assert isinstance(g, G_x0)
    x = XLeech2(0x800000) * g
    return x.ord & 0xffffff


class UnionFindLeech2:
    """Union-find algorithm for vectors in Leech lattice mod 2

    This class implements the union-find algorithm on the Leech
    lattice mod 2.

    Method ``union_g`` called with parameter ``g``,  ``g`` in G_x0,
    unites the vector ``v`` with the  vector ``v * g``, for all
    vectors ``v`` in the Leech lattice mod 2.

    Let G be the subgroup of G_x0 generated by all elements ``g``
    previously passed to method ``union_g``. Then the equivalence
    classes obtained after these calls to method ``union_g`` are
    just the orbits of G on the Leech lattice mod 2.

    Method ``find`` called with parameter ``v`` returns the
    representative of the G orbit of ``v``. Here ``v`` and the
    result are elements of the Leech lattice mod 2 encoded as
    integers representing bit vectors.

    Method ``counter`` returns a dictionary that maps the
    representatives of the G orbits to sizes of the orbits.
    Here the representatives are encoded as in method ``find``.
 
    Calls to method ``union_g`` are illegal after a call to
    method ``find`` or ``counter``.

    In theory there are faster methods for computing G orbits. But
    our union-find algorithm is present in mmgroup, implemented
    in C, and not related to the Monster group in any way.
    """
    def __init__(self):
        self.a = np.zeros(0x1000000, dtype = np.uint32)
        self.finished = False
        gen_ufind_init(self.a, len(self.a))
    def union_g(self, g):
        assert isinstance(g, G_x0)
        assert not self.finished
        gm = g.as_compressed_Co1_bitmatrix()
        st = gen_ufind_union_affine(self.a, 24, gm, 0)
        assert st >= 0
    def find(self, v):
        if not self.finished:
            assert gen_ufind_find_all_min(self.a, len(self.a))  >= 0
            self.finished = True
        res = gen_ufind_find(self.a, len(self.a), v)
        assert res >= 0
        return res
    def counter(self):
        a_map = np.zeros(len(self.a), dtype = np.uint32)
        self.find(0)
        assert gen_ufind_make_map(self.a, len(self.a), a_map) >= 0
        return Counter(a_map)

def check_axis(ch):
    """Check data for an axis read from a certificate

    Here parameter ``ch`` must be an instance of class ``AxisChecker``.
    That instance contains data about a specific axis ``ax``
    collected from the certificate.

    Let G be the subgroup of G_x0 generated by the list in member
    ``ch.centralizer``. We compute the orbits of G on the type-4
    vectors in the Leech lattice mod 2 using class ``UnionFindLeech2``.
    In a check prior to the call of this function we have already
    verified that G is a subgroup of the centralizer of the axis. 

    Let ``orb`` be the list of representatives of N_x0 orbits
    contained in the G_x0 orbit of the axis, as given by the list
    in member ``ch.orbits``. The entry in the list for an axis
    ``ax1`` representing an N_x0 orbit contains an element ``h``
    of G_x0 with ``ax * h == ax1``, and a number ``k`` indicating
    the size of the orbit.

    As in the paper, we associate axis ``ax1 = ax * h`` with the
    element ``Omega * h**-1`` in the Leech lattice mod 2, where
    ``Omega`` is the standard frame in the Leech lattice mod 2. 
    For each axis ``ax1`` to which the list ``ch.orbits`` refers,
    we check that the G orbit of ``Omega * h**-1`` has precisely
    the size ``k`` stored for that axis.

    We also check that the sum of all values ``k`` obtained from
    the list ``ch.orbits`` is equal to the number of type-4
    vectors in the Leech lattice mod 2.

    If any of these checks fails the function raisens an execption.
    """
    assert isinstance(ch, AxisChecker)
    uf = UnionFindLeech2()
    d = {}
    for g in ch.centralizer:
        uf.union_g(g)
    for orbit_size, h in ch.orbits:
        d[img_Omega_G_x0(h**-1)] = orbit_size
    counter = uf.counter()
    #print(counter)
    for v, orbit_size in d.items():
        assert counter[uf.find(v)] == orbit_size
    #print(sum(d.values()))
    assert sum(d.values()) == NUM_TYPE4_VECTORS


def get_suborbits_from_shelve():
    """Return the suborbit table from the shelve.

    This table corresponds to Table 2 in the paper.
    The function returns None if no suborbit table in the shelve
    has been found.
    """
    import shelve
    THIS_DIR = os.path.split(__file__)[0]
    SHELVE_DIR = os.path.join(THIS_DIR, "..", "axis", "shelve")
    SHELVE_NAME = os.path.realpath(
        os.path.join(SHELVE_DIR, "mat24_orbit_tables"))
    try:
        with shelve.open(SHELVE_NAME) as db:
            shelve_suborbits = db["mat24_suborbits"]
        return shelve_suborbits
    except:
        return None
     

def get_suborbit_table_from_certificate(certificate_path):
    """Return suborbit table computed from the certificate.

    This table corresponds to Table 2 in the paper.
    """
    d = defaultdict(int)
    for s in open(certificate_path):
        tag, n, g = parse_line(s)
        if tag == 'axis':
            current_axis = n
        if tag == 'orb':
            current_orbit_size = n
        if tag.startswith('tau'):
            d[current_axis, n] += current_orbit_size
    return d

def check_suborbits_against_shelve(certificate_path):
    """Check suborbit table computed from certificate against shelve.

    This suborbit table is Table 2 in the paper.
    The function raises an exception if the suborbit table computed
    from the certificate differs from the corresponding table in the
    shelve. It prints a message if no shelve containg a suitable
    suborbit table  has been found. 
    """
    d_shelve = get_suborbits_from_shelve()
    if d_shelve is not None:
        print("""
Computing Table 2 in the paper from the certificate ...""")
        d_cert = get_suborbit_table_from_certificate(certificate_path)
        assert d_cert == d_shelve, (d_cert , d_shelve)
        print("Table agrees with corresponding table in the shelve.")
    else:
        print("""
Cannot compare certificate against data in the shelve.
No shelve containg a suitable suborbit table found!""") 
        


def check_certificate(certificate_path):
    """Check the certificate for correctness.

    The function read the certificate given by parameter
    ``certificate_path``. It first computes the representatives of
    the G_x0 orbits of the axes stored in the certificate. It also
    reads the generarators of the centralizers of the axes and
    checks that they indeed centralize an axis as claimed in the
    cerificate. 

    For each axis ``ax`` representing a G_x0 orbit the function
    collects the axes representing the N_x0 orbits contained in that 
    orbit from the certificate. For any of these collected axes
    ``ax1`` the certificate contains the size of the N_x0 orbit
    of ``ax1``. The triality element ``\tau`` of the Monster and its
    inverse map ``ax1`` to axes in G_x0 orbits that may differ from
    the G_x0 orbit of``ax1``. Here the certificate contains
    information how to map the axes ``ax1 * \tau^{+-1}`` to the
    representatives of their G_x0 orbits. Thus the G_x0 orbits of
    ``ax1 * \tau^{+-1}`` may easily be obtained from the information
    in the certificate. The sizes of the N_x0 orbits of the axes
    ``ax``, and the G_x0 orbits of the images of ``ax`` under
    ``\tau^{+-1}``, are sufficient to conmpute Table 2 in the paper.

    It remains to show that the N_x0 orbits contained in a G_x0
    orbit make up the complete G_x0 orbit. The paper explains how
    this claim can be established. For doing so we collect the
    information about an axis representing a G_x0 orbit in an 
    object of class ``AxisChecker``. The we apply function
    ``check_axis`` to that object in order to verify the claim.
    As explained in the paper, we cannot and need not be sure that
    the group G_0 generated by the elements in the certificate 
    centralizing axis ``ax`` is equal to the centralizer G of axis
    ``ax`` in G_x0.

    From the infomation in the certificate we can easily compute
    Table 2 in the paper. Here we check if the Table 2 computed
    in this way agrees with the Table 2 computed by the programs
    in subdirectory 'axis' of the project. 
    """
    start_time = time.time()
    axis_dict = find_axes(certificate_path)
    #print(axis_dict.keys())
    last = None
    axes_found = set()
    print(f"Verifying certificate '{certificate_path}'")
    print("Orbits checked: ", end = "")
  
    for s in open(certificate_path):
        tag, n, g = parse_line(s)
        if tag == 'axis':
             ch = AxisChecker()
             ch.name, ch.axis = n, STD_AXIS * M(g) 
        if tag == 'cent':
             c = G_x0(g) 
             if n == 1:
                 ch.centralizer.append(c)
             assert ch.axis * c == ch.axis
        if tag == 'orb':
             orbit_size, g_orbit = n, G_x0(g)
             orbit_axis = ch.axis * g_orbit
        if tag == 'tau1':
             assert last == 'orb'
             tau_axis = orbit_axis * T1 * M(g)
             assert tau_axis ==  axis_dict[n]   
        if tag == 'tau2':
             assert last == 'tau1'
             tau_axis = orbit_axis * T2 * M(g)
             assert tau_axis ==  axis_dict[n] 
             ch.orbits.append([orbit_size, g_orbit]) 
        if tag == 'end':
             check_axis(ch)
             axes_found.add(ch.name)
             print(ch.name, end = " ", flush = True)           
             del ch 
        last = tag
    #print( set(axis_dict.keys()), axes_found)
    assert set(axis_dict.keys()) == axes_found
    t = time.time() - start_time
    print("\nCertificate is correct. Verifying took %.2f seconds" % t)
    check_suborbits_against_shelve(certificate_path)

if __name__ == "__main__":
     CERTIFICATE_PATH =  "axis_certificate.txt"
     check_certificate(CERTIFICATE_PATH)


