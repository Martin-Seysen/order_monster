import sys
import os
from collections import defaultdict, OrderedDict
import re
import numpy as np

from mmgroup import MM0, XLeech2, mat24, MM, Xsp2_Co1
from mmgroup.general import Orbit_Lin2
from mmgroup.general import Orbit_Elem2
from collections.abc import Iterable

######################################################################
# Compute order and 2-structure of a subgroup of N_x0
######################################################################

def map_mat24(g):
    m = g.as_compressed_Co1_bitmatrix()
    return [v & 0x7ff for v in m[:11]]

def map_y(g):
    result = 0
    for tag, value in g.as_tuples():
        if tag == 'y':
            result ^= value & 0x7ff
        elif tag not in 'dx':
            ERR = "Element is not in 2-subgroup of N_x0"
            raise ValueError(ERR)
    return result

def map_x(g):
    x = XLeech2(g)
    return x.ord & 0xffffff


def is_Nx0_odd(g):
    r"""Return 0 or 1 if ``g`` is an even or odd element of :math`N_{x0}`

    The function fails if ``g`` is not in :math`N_{x0}`
    """
    odd =  0
    for t in Xsp2_Co1(g).mmdata:
        tag = (t >> 28) & 7
        assert 0 <= tag  <= 4
        if tag == 1:
            odd |= t
    return (odd >> 11) & 1




def trim_N_x0(glist, map = lambda x:x):
    r"""Rearrange list of elements of a subgroup of :math`N_{x0}`.  

    The list ``glist`` of entries of a subgroup of :math`N_{x0}`
    is rearranges so that at most the first entry of the list
    corresponds to an odd element of :math`N_{x0}`. An odd
    element of :math`N_{x0}` is an element containing a factor
    :math:`x_\delta, \delta \in \matchal{C}^*, delta \mbox{ odd}`.
    """
    if isinstance(glist, Orbit_Lin2):
        glist = Orbit_Lin2.generators()
    glist = [Xsp2_Co1(g) for g in glist]
    g_odd = None
    for i, g in enumerate(glist):
        if is_Nx0_odd(g):
            if g_odd is None:
                g_odd = g
                glist[i] = None
            else:
                glist[i] *= g_odd 
    return [map(x) for x in [g_odd] + glist if x != None]


def order_Nx0(glist, e_odd = True):
    r"""Compute order of a subgroup of :math`N_{x0}`.

    We first describe the default action of the function in
    case ``e_odd = Truee``.

    Parameter ``glist`` describes a list of generators of a subgroup
    :math:`H` of :math:`N_{x0}`. Here :math:`N_{x0}` has structure
    :math:`2^{2+11+22}.(M_{24} \times 2)`. As a subgroup of
    :math`N_{x0}`, the group :math:`H` has a structure
    :math:`2^e.(H_f \times 2^s)`. The function returns a
    triple  ``(e, f, s)``, where part ``e`` describes the structure of
    :math:`2^e`, part  ``f`` is the order of :math:`H_f`, and ``s``
    is the exponent of the group :math:`2^s`.

    Part ``e`` is a tuple of length 5 describing a subgroup of the
    2 group :math:`2^{2+11+22}`.  The exponent of the 2 group is
    decomposed  as : math:`1+1+11+11+11`, with the i-th component
    ``e_i`` generated by the following generators:
    
    e_0:  :math:`x_{-1}`  
    
    e_1:  :math:`x_{\Omega}`  
    
    e_2:  :math:`x_{\delta}, \;  \delta \in \mathcal{C}^* \, \mbox{even}`  
    
    e_3:  :math:`x_{d}, \;  d \in \mathcal{C}  
    
    e_4:  :math:`y_{d}, \;  d \in \mathcal{C} 

    In case ``e_odd = False`` we decompose the subgroup :math:`H` of
    :math:`N_{x0}` along the lines :math:`N_{x0} = 2^{2+11+22+1}.M_{24}`.
    in this case we return a pair ``(e, f)``, with ``f`` and above, and
    ``e = (e_0,...,e_5)``. Here ``e_0,...,e_4`` are as above; and ``e_5``
    is the group generate by the generators:

    e_5:  :math:`x_{\delta}, \;  \delta \in \mathcal{C}^* \, \mbox{odd}`.  
    """
    if e_odd:
        glist = trim_N_x0(glist)
        odd = is_Nx0_odd(glist[0])
        glist = glist[odd:]
    orb_m24 = Orbit_Lin2(map_mat24, glist)   
    factor_pi, stab = orb_m24.order_kernel(n_gen = 40)
    orbit_y = Orbit_Elem2(map_y, stab)
    orbit_y.set_rand_parameters(50, 100)
    e_y = orbit_y.exp
    stab_x = [XLeech2(orbit_y.rand_kernel()) for i in range(35)]
    orbit_x = Orbit_Elem2(map_x, stab_x)
    orbit_x.set_rand_parameters(50, 100)
    e_x = orbit_x.structure_2([(23, 24), (0, 11), (12, 23), (11, 12)]) 
    stab_central = set([orbit_x.rand_kernel().ord  for i in range(35)])
    e_central = int(len(stab_central) > 1)
    e = [e_central] + e_x[:3] + [e_y]
    if e_odd:
        assert e_x[3] == 0, e_x
        return e, factor_pi, int(odd) 
    else:
        e.append(e_x[3])
        return e, factor_pi

######################################################################
# Compute order and 2-structure of a subgroup of G_x0
######################################################################


def compute_order(lin2_orbit, verbose = 0):
    assert isinstance(lin2_orbit, Orbit_Lin2)
    lin2_orbit.set_rand_parameters(50, 100)
    v = 0x800000
    factor1 = lin2_orbit.orbit_size(v)
    m24_stab = [lin2_orbit.rand_stabilizer(v) for i in range(40)]
    e, order_m24, s = order_Nx0(m24_stab)
    return (1 << e[0], 1 << (sum(e[1:-1]) + s), 
        (factor1 * order_m24) << e[-1])

######################################################################
# Convert elements of N_0 to GAP permutations
######################################################################
  


def permutation_to_cycles(perm):
    visited = set()
    cycles = []
    perm = [x + 1 for x in perm]
    for i in range(len(perm)):
        if i + 1 not in visited:  # GAP uses 1-based indexing
            cycle = []
            x = i + 1
            while x not in visited:
                visited.add(x)
                cycle.append(x)
                x = perm[x - 1]  # Move to the next element in the permutation
            if len(cycle) > 1:
                cycles.append(cycle)
    #print(cycles)
    if not cycles:
        return "()"  # GAP represents the identity permutation as ()
    return "".join(f"({','.join(map(str, cycle))})" for cycle in cycles)


def MM_to_GAP(g, conj = None):
    NEUTRAL = MM()
    if isinstance(g, (list, tuple)):
        conj = MM(conj) if conj else NEUTRAL
        glist = [NEUTRAL]
        for x in g:
            m = MM(x) ** conj
            if m not in glist and m != NEUTRAL:
                glist.append(m)
        s = ",\n".join([MM_to_GAP(x) for x in glist[1:]])  
        return "[%s]" % s
    return permutation_to_cycles(MM(g).as_M24_permutation())
      

######################################################################
# Convert GAP structure description of a group to LaTeX
######################################################################


def _as_str(s):
    if s is None:
        return ""
    return str(s) 

m_C = re.compile(r"(\()?\s*(C\d+(?:\s+x\s+C\d+)*)\s*(\))?")

def sub_m_C(m):
    open, text, close = m.groups()
    factors = [int(s.strip()[1:]) for s in text.split('x')]
    d = OrderedDict()
    for f in factors:
        if f not in d:
            d[f] = 0
        d[f] += 1
    data = ["%d^%d" % (f,e) if e > 1 else str(f) for f, e in d.items()]
    s = r"\times ".join(data)
    if open == "(" and close == ")" and len(data) == 1:
         open = close = "" 
    return _as_str(open) + s + _as_str(close)

m_A = re.compile(r"([AMSDQ])(\d+)")

def sub_m_A(m):
    g, index = m.groups()
    return g + "_{%s}" % index

m_L = re.compile(r"(P?[SG]L)\(\s*(\d+),\s*(\d+)\s*\)")
     
def sub_m_L(m):
    g, i1, i2 = m.groups()
    return r"\mbox{%s}_{%s}(%s)" % (g, i1, i2)


SUB_M_DICT = {
    m_C : sub_m_C, 
    'x' : r'\\times ',
     m_A : sub_m_A,
     m_L : sub_m_L,
    '  ' : ' '
}


def sub_structure_description(s):
    for pattern, replace in SUB_M_DICT.items():
        s = re.sub(pattern, replace, s)
    return s

def test_sub_structure_description():
    m = re.compile(r"(G\d+\s*=\s*)(.+)$")
    for s in open("Nx0_orbit_structure.txt"):
        mm = m.match(s)
        if mm:
            name, data = mm.groups()
            subst = sub_structure_description(data)
            print("%7s%-33s %-30s" % (name, subst, data))




